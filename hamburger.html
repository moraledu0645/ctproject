<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>í–„ë²„ê±° ì™„ì„±í’ˆ ì˜ˆì¸¡í•˜ê¸° ğŸ”</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
    }
    h1, h2 {
      color: #333;
    }
    .rule-box {
      background-color: #f0f0f0;
      border-left: 5px solid #888;
      padding: 10px;
      margin-bottom: 20px;
      white-space: pre-wrap;
    }
    select, button {
      margin: 5px;
      padding: 5px;
      font-size: 16px;
    }
    .output {
      margin-top: 20px;
      padding: 10px;
      background-color: #e6f7ff;
      border: 1px solid #b3e0ff;
    }
  </style>
</head>
<body>

  <h1>í–„ë²„ê±° ì™„ì„±í’ˆ ì˜ˆì¸¡í•˜ê¸° ğŸ”</h1>
  <h2>ëŒ€ìƒ ë° êµê³¼: ì¤‘1 (ë…¼ë¦¬ì ì‚¬ê³ )</h2>

  <div class="rule-box" id="rulesDisplay">
    </div>

  <label>ì‚¬ìš©í•  ì¬ë£Œ ì„ íƒ (ì•„ë˜ì—ì„œ ìœ„ ìˆœì„œë¡œ ì„ íƒ):</label><br>
  <div id="selectors"></div>

  <br><br>
  <button onclick="checkBurger()">ë¬¸ì œ í’€ê¸°</button>
  <button onclick="generateNewProblem()">ìƒˆë¡œìš´ ë¬¸ì œ ìƒì„±</button>

  <div class="output" id="result"></div>

  <script>
    const allAvailableIngredients = [
      { label: "ì–‘ìƒì¶” ğŸ¥¬", value: "ì–‘ìƒì¶”" },
      { label: "ê³ ê¸°(íŒ¨í‹°) ğŸ¥©", value: "ê³ ê¸°" },
      { label: "ì¹˜ì¦ˆ ğŸ§€", value: "ì¹˜ì¦ˆ" },
      { label: "í† ë§ˆí†  ğŸ…", value: "í† ë§ˆí† " },
      { label: "ì–‘íŒŒ ğŸ§…", value: "ì–‘íŒŒ" },
      { label: "ì†ŒìŠ¤ ğŸ¥«", value: "ì†ŒìŠ¤" },
      { label: "ë²„ì„¯ ğŸ„", value: "ë²„ì„¯" },
      { label: "ìƒˆìš° ğŸ¤", value: "ìƒˆìš°" },
      { label: "ì¹˜í‚¨ ğŸ—", value: "ì¹˜í‚¨" },
      { label: "í• ë¼í”¼ë‡¨ ğŸŒ¶ï¸", value: "í• ë¼í”¼ë‡¨" }
    ];

    const fixedIngredients = [
      { label: "ë¹µ ğŸ", value: "ë¹µ" },
      { label: "ë®ê°œë¹µ ğŸ", value: "ë®ê°œë¹µ" }
    ];

    const container = document.getElementById("selectors");
    const rulesDisplay = document.getElementById("rulesDisplay");
    let currentRules = [];
    let currentCorrectAnswer = [];
    let currentSelectedIngredients = []; // í˜„ì¬ ë¬¸ì œì— ì‚¬ìš©ë  8ê°€ì§€ ì¬ë£Œ (ë¼ë²¨ í¬í•¨)

    const totalBurgerLayers = 8; // ì´ 8ê°œ ì¬ë£Œë§Œ ì‚¬ìš©

    // ë°°ì—´ ì„ê¸° í•¨ìˆ˜
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // ì…€ë ‰í„° ì´ˆê¸°í™” í•¨ìˆ˜ (ë¬¸ì œ ìƒì„± ì‹œë§ˆë‹¤ ì¬ë£Œ ëª©ë¡ ì—…ë°ì´íŠ¸)
    function initializeSelectors() {
      container.innerHTML = ''; // ê¸°ì¡´ ì…€ë ‰í„° ëª¨ë‘ ì œê±°

      const fullIngredientListForSelectors = [{ label: "ì„ íƒ", value: "" }, ...currentSelectedIngredients];

      for (let i = 1; i <= totalBurgerLayers; i++) {
        const select = document.createElement("select");
        select.id = "ingredient" + i;
        fullIngredientListForSelectors.forEach(ing => {
          const option = document.createElement("option");
          option.value = ing.value;
          option.textContent = ing.label;
          select.appendChild(option);
        });
        container.appendChild(select);
      }
    }

    function generateNewProblem() {
      currentRules = [];
      let ruleText = "<ê·œì¹™>\n";
      let ruleCounter = 0;

      // 1. 8ê°œì˜ ì¬ë£Œë¥¼ ë¬´ì‘ìœ„ë¡œ ì„ íƒí•©ë‹ˆë‹¤.
      // ë¹µ, ë®ê°œë¹µ, ì†ŒìŠ¤ë¥¼ í¬í•¨í•˜ì—¬ 8ê°œ. ì†ŒìŠ¤ëŠ” ì´ì œ ê³ ì • ì¬ë£Œê°€ ì•„ë‹˜.
      // 'ë¹µ'ê³¼ 'ë®ê°œë¹µ'ì€ í•­ìƒ í¬í•¨ë˜ë¯€ë¡œ, 6ê°œì˜ ì¬ë£Œë§Œ ì¶”ê°€ë¡œ ì„ íƒí•©ë‹ˆë‹¤.
      const otherIngredients = allAvailableIngredients.filter(ing => ing.value !== "ì†ŒìŠ¤"); // ì†ŒìŠ¤ë¥¼ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ì¬ë£Œ
      
      const shuffledOtherIngredients = shuffleArray([...otherIngredients]);
      const selectedDynamicIngredients = shuffledOtherIngredients.slice(0, 5); // 5ê°œë§Œ ì„ íƒ (ì†ŒìŠ¤ í¬í•¨í•´ì„œ ì´ 6ê°œ)

      // ìµœì¢… 8ê°œ ì¬ë£Œ ëª©ë¡ êµ¬ì„±: ë¹µ, ë®ê°œë¹µ, ì†ŒìŠ¤, ê·¸ë¦¬ê³  ë¬´ì‘ìœ„ 5ê°œ ì¬ë£Œ
      currentSelectedIngredients = [
          ...fixedIngredients, // ë¹µ, ë®ê°œë¹µ
          { label: "ì†ŒìŠ¤ ğŸ¥«", value: "ì†ŒìŠ¤" }, // ì†ŒìŠ¤ëŠ” ì´ì œ í•„ìˆ˜ í¬í•¨ (8ê°œ ì¤‘ 3ê°œ)
          ...selectedDynamicIngredients // ë¬´ì‘ìœ„ 5ê°œ ì¬ë£Œ (8ê°œ ì¤‘ 5ê°œ)
      ];

      // ê²¹ì¹˜ì§€ ì•ŠëŠ” ìˆœì—´ì„ ë§Œë“¤ê¸° ìœ„í•œ í—¬í¼ í•¨ìˆ˜
      function generatePermutations(arr) {
          if (arr.length === 0) return [[]];
          if (arr.length === 1) return [arr];

          const result = [];
          for (let i = 0; i < arr.length; i++) {
              const head = arr[i];
              const rest = arr.slice(0, i).concat(arr.slice(i + 1));
              for (const p of generatePermutations(rest)) {
                  result.push([head, ...p]);
              }
          }
          return result;
      }

      // 2. ì„ íƒëœ 8ê°œ ì¬ë£Œë¡œ ê°€ëŠ¥í•œ ëª¨ë“  ë²„ê±° ìˆœì—´ì„ ìƒì„±í•©ë‹ˆë‹¤.
      const ingredientsForPermutation = currentSelectedIngredients.map(ing => ing.value);
      const allPossiblePermutations = generatePermutations(ingredientsForPermutation);

      // ë¹µê³¼ ë®ê°œë¹µì´ ë§¨ ì•„ë˜ì™€ ë§¨ ìœ„ì— ê³ ì •ëœ ìœ íš¨í•œ ìˆœì—´ë§Œ í•„í„°ë§í•©ë‹ˆë‹¤.
      const validPermutations = allPossiblePermutations.filter(perm =>
          perm[0] === "ë¹µ" && perm[totalBurgerLayers - 1] === "ë®ê°œë¹µ"
      );
      
      // ë§Œì•½ ìœ íš¨í•œ ìˆœì—´ì´ ì—†ë‹¤ë©´ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤. (ì´ëŸ° ê²½ìš°ëŠ” ê±°ì˜ ì—†ê² ì§€ë§Œ, ë§Œì•½ì„ ëŒ€ë¹„)
      if (validPermutations.length === 0) {
          console.warn("[ê²½ê³ ] ìœ íš¨í•œ í–„ë²„ê±° ìˆœì—´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.");
          generateNewProblem(); // ì¬ê·€ í˜¸ì¶œë¡œ ë‹¤ì‹œ ë¬¸ì œ ìƒì„± ì‹œë„
          return;
      }

      // í•„í„°ë§ëœ ìœ íš¨í•œ ìˆœì—´ ì¤‘ í•˜ë‚˜ë¥¼ ì •ë‹µìœ¼ë¡œ ì„ íƒí•©ë‹ˆë‹¤.
      currentCorrectAnswer = shuffleArray(validPermutations)[0];
      const solutionIdx = (item) => currentCorrectAnswer.indexOf(item);

      // 3. ê³ ì •ëœ í•„ìˆ˜ ê·œì¹™ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
      // ê·œì¹™ 1: ë§¨ ì•„ë˜ëŠ” ë°˜ë“œì‹œ 'ë¹µ', ë§¨ ìœ„ëŠ” ë°˜ë“œì‹œ 'ë®ê°œë¹µ' (ì´ê²ƒì€ ì´ë¯¸ validPermutationsì— ì˜í•´ ë³´ì¥ë˜ì§€ë§Œ, ê·œì¹™ìœ¼ë¡œ ëª…ì‹œ)
      currentRules.push({
        validation: (selected, idx) => selected[0] === "ë¹µ" && selected[selected.length - 1] === "ë®ê°œë¹µ",
        errorMsg: "âŒ ê·œì¹™: ë§¨ ì•„ë˜ì—ëŠ” ë¹µ, ë§¨ ìœ„ì—ëŠ” ë®ê°œë¹µì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤."
      });
      ruleText += `${koreanAlphabet[ruleCounter++]}. ë§¨ ì•„ë˜ì—ëŠ” ë¹µ, ë§¨ ìœ„ì—ëŠ” ë®ê°œë¹µì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.\n`; // ê°€.

      // 4. ì„ íƒëœ ì •ë‹µì— ë”°ë¼ ë™ì  ê·œì¹™ì„ ìƒì„±í•©ë‹ˆë‹¤.
      // ë™ì  ê·œì¹™ì— ì‚¬ìš©ë  ì¬ë£Œ (ë¹µ, ë®ê°œë¹µ ì œì™¸)
      const dynamicIngredients = currentCorrectAnswer.filter(ing =>
        ing !== "ë¹µ" && ing !== "ë®ê°œë¹µ"
      );

      // ëª©í‘œë¡œ í•˜ëŠ” ë™ì  ê·œì¹™ì˜ ê°œìˆ˜ (ìµœì†Œ 4ê°œ ~ ìµœëŒ€ 8ê°œ)
      const minDynamicRules = 4;
      const maxDynamicRules = 8;
      let desiredDynamicRulesCount = Math.floor(Math.random() * (maxDynamicRules - minDynamicRules + 1)) + minDynamicRules;

      const possibleUniqueRuleCombinations = [];
      const tempRuleTextSet = new Set(); // í…ìŠ¤íŠ¸ ì¤‘ë³µ ê²€ì‚¬ìš© Set

      // ëª¨ë“  'ìœ„ì—/ì•„ë˜ì—' ê´€ê³„ ê·œì¹™ ì¡°í•© ìƒì„±
      for (let i = 0; i < dynamicIngredients.length; i++) {
        const ingA = dynamicIngredients[i];
        for (let j = i + 1; j < dynamicIngredients.length; j++) {
          const ingB = dynamicIngredients[j];

          const idxA = solutionIdx(ingA);
          const idxB = solutionIdx(ingB);

          if (idxA === -1 || idxB === -1) continue; 

          let rule = null;
          if (idxB < idxA) { // Bê°€ Aë³´ë‹¤ ì•„ë˜ì— ìˆë‹¤ë©´ (Aê°€ B ìœ„ì— ìˆìŒ)
            rule = {
              text: `${ingA}ì€(ëŠ”) ${ingB} ìœ„ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.`,
              validation: (selected, currentSelectedIdx) => currentSelectedIdx(ingB) < currentSelectedIdx(ingA),
              errorMsg: `âŒ ê·œì¹™: ${ingA}ì€(ëŠ”) ${ingB} ìœ„ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.`
            };
          } else if (idxA < idxB) { // Aê°€ Bë³´ë‹¤ ì•„ë˜ì— ìˆë‹¤ë©´ (Bê°€ A ìœ„ì— ìˆìŒ)
            rule = {
              text: `${ingB}ì€(ëŠ”) ${ingA} ìœ„ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.`,
              validation: (selected, currentSelectedIdx) => currentSelectedIdx(ingA) < currentSelectedIdx(ingB),
              errorMsg: `âŒ ê·œì¹™: ${ingB}ì€(ëŠ”) ${ingA} ìœ„ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.`
            };
          }

          if (rule && !tempRuleTextSet.has(rule.text)) {
            possibleUniqueRuleCombinations.push(rule);
            tempRuleTextSet.add(rule.text);
          }
        }
      }

      // ëª¨ë“  'ì‚¬ì´ì—' ê´€ê³„ ê·œì¹™ ì¡°í•© ìƒì„±
      if (dynamicIngredients.length >= 3) {
        for (let i = 0; i < dynamicIngredients.length; i++) {
          const ingA = dynamicIngredients[i];
          for (let j = i + 1; j < dynamicIngredients.length; j++) {
            const ingB = dynamicIngredients[j];
            for (let k = j + 1; k < dynamicIngredients.length; k++) {
              const ingC = dynamicIngredients[k];

              const idxA = solutionIdx(ingA);
              const idxB = solutionIdx(ingB);
              const idxC = solutionIdx(ingC);

              if (idxA === -1 || idxB === -1 || idxC === -1) continue;

              const sortedByPos = [
                  { ing: ingA, idx: idxA },
                  { ing: ingB, idx: idxB },
                  { ing: ingC, idx: idxC }
              ].sort((x, y) => x.idx - y.idx);

              const middleIng = sortedByPos[1].ing;
              const outer1 = sortedByPos[0].ing;
              const outer2 = sortedByPos[2].ing;

              const rule = {
                  text: `${middleIng}ì€(ëŠ”) ${outer1}ì™€ ${outer2} ì‚¬ì´ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.`,
                  validation: (selected, currentSelectedIdx) => {
                      const iM = currentSelectedIdx(middleIng), iO1 = currentSelectedIdx(outer1), iO2 = currentSelectedIdx(outer2);
                      if (iM === -1 || iO1 === -1 || iO2 === -1) return false;
                      return (iO1 < iM && iM < iO2) || (iO2 < iM && iM < iO1);
                  },
                  errorMsg: `âŒ ê·œì¹™: ${middleIng}ì€(ëŠ”) ${outer1}ì™€ ${outer2} ì‚¬ì´ì— ìˆì–´ì•¼ í•©ë‹ˆë‹¤.`
              };

              if (!tempRuleTextSet.has(rule.text)) {
                possibleUniqueRuleCombinations.push(rule);
                tempRuleTextSet.add(rule.text);
              }
            }
          }
        }
      }
      
      // ì‹¤ì œ ìƒì„± ê°€ëŠ¥í•œ ê³ ìœ  ê·œì¹™ì˜ ê°œìˆ˜ë¥¼ ë„˜ì§€ ì•Šë„ë¡ ëª©í‘œ ê°œìˆ˜ ì¡°ì •
      desiredDynamicRulesCount = Math.min(desiredDynamicRulesCount, possibleUniqueRuleCombinations.length);


      // ìƒì„± ê°€ëŠ¥í•œ ê³ ìœ  ê·œì¹™ ì¡°í•©ì„ ì„ì€ í›„, ì›í•˜ëŠ” ê°œìˆ˜ë§Œí¼ ì„ íƒí•©ë‹ˆë‹¤.
      const shuffledUniquePossibleRules = shuffleArray(possibleUniqueRuleCombinations);
      
      for (let i = 0; i < shuffledUniquePossibleRules.length && currentRules.length < (desiredDynamicRulesCount + 1); i++) { // +1ì€ ê³ ì • ê·œì¹™ 1ê°œ
        const ruleToAdd = shuffledUniquePossibleRules[i];
        
        currentRules.push({
          validation: ruleToAdd.validation,
          errorMsg: ruleToAdd.errorMsg
        });
        ruleText += `${koreanAlphabet[ruleCounter++]}. ${ruleToAdd.text}\n`;
      }

      // ë§Œì•½ ì›í•˜ëŠ” ê°œìˆ˜ë§Œí¼ ê·œì¹™ì„ ì±„ìš°ì§€ ëª»í–ˆë”ë¼ë„ ë£¨í”„ëŠ” ì¢…ë£Œë©ë‹ˆë‹¤.
      if (currentRules.length < (desiredDynamicRulesCount + 1)) {
         console.warn(`[ê²½ê³ ] ëª©í‘œ ê·œì¹™ ê°œìˆ˜(${desiredDynamicRulesCount + 1})ë¥¼ ì±„ìš°ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. í˜„ì¬ ê·œì¹™ ê°œìˆ˜: ${currentRules.length}`);
      }

      ruleText += "</ê·œì¹™>";
      rulesDisplay.innerHTML = ruleText;
      document.getElementById("result").innerHTML = ""; // ì´ì „ ê²°ê³¼ ì§€ìš°ê¸°
      
      // ë¬¸ì œì— ì‚¬ìš©ë  ì¬ë£Œ ëª©ë¡ìœ¼ë¡œ ì…€ë ‰í„° ì—…ë°ì´íŠ¸
      initializeSelectors();
    }

    // ê·œì¹™ ë²ˆí˜¸ ë§¤ê¸°ê¸°ë¥¼ ìœ„í•œ í•œê¸€ ìëª¨
    const koreanAlphabet = ['ê°€', 'ë‚˜', 'ë‹¤', 'ë¼', 'ë§ˆ', 'ë°”', 'ì‚¬', 'ì•„', 'ì', 'ì°¨', 'ì¹´', 'íƒ€', 'íŒŒ', 'í•˜', 'ê±°', 'ë„ˆ', 'ë”', 'ëŸ¬', 'ë¨¸', 'ë²„', 'ì„œ', 'ì–´', 'ì €', 'ì²˜', 'ì»¤', 'í„°', 'í¼', 'í—ˆ'];

    function checkBurger() {
      const selected = [];
      for (let i = 1; i <= totalBurgerLayers; i++) {
        const val = document.getElementById("ingredient" + i).value;
        if (val) selected.push(val);
      }

      // í˜„ì¬ ë¬¸ì œì— ì‚¬ìš©ë˜ëŠ” ì¬ë£Œë“¤ë§Œ ê°€ì§€ê³  ìœ íš¨ì„± ê²€ì‚¬
      const currentProblemIngredients = currentSelectedIngredients.map(ing => ing.value);
      const counts = {};

      selected.forEach(item => {
        counts[item] = (counts[item] || 0) + 1;
      });

      const idx = (item) => selected.indexOf(item);
      const msg = [];

      // ëª¨ë“  í•„ìˆ˜ ì¬ë£Œê°€ ì‚¬ìš©ë˜ì—ˆëŠ”ì§€, ì¤‘ë³µ ì‚¬ìš©ì€ ì—†ëŠ”ì§€ í™•ì¸
      currentProblemIngredients.forEach(item => {
        if (!counts[item]) {
          msg.push(`âŒ í•„ìˆ˜ ì¬ë£Œ ëˆ„ë½: ${item} ì´(ê°€) ë¹ ì¡ŒìŠµë‹ˆë‹¤.`);
        } else if (counts[item] > 1) {
          msg.push(`âŒ ì¬ë£Œ ì¤‘ë³µ ì‚¬ìš©: ${item} ì´(ê°€) ${counts[item]}ë²ˆ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }
      });
      
      // ì •í™•íˆ ëª¨ë“  ë ˆì´ì–´ ìˆ˜ë§Œí¼ ì¬ë£Œê°€ ì„ íƒë˜ì—ˆëŠ”ì§€ í™•ì¸
      if (selected.length !== totalBurgerLayers) {
          msg.push(`âŒ ëª¨ë“  ${totalBurgerLayers}ì¹¸ì— ì¬ë£Œë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤.`);
      }

      // í˜„ì¬ ìƒì„±ëœ ê·œì¹™ë“¤ì— ë”°ë¼ ìœ íš¨ì„± ê²€ì‚¬
      currentRules.forEach(rule => {
        if (!rule.validation(selected, idx)) {
          msg.push(rule.errorMsg);
        }
      });

      const resultBox = document.getElementById("result");
      resultBox.innerHTML = msg.length === 0
        ? "âœ… ì •ë‹µì…ë‹ˆë‹¤! í–„ë²„ê±° ì™„ì„±!"
        : msg.join("<br>");
    }

    // ì´ˆê¸° ë¡œë”© ì‹œ ë¬¸ì œ ìƒì„±
    generateNewProblem();
  </script>

</body>
</html>
